from dataclasses import dataclass, field
from DateTime import DateTime
from typing import Literal
from enum import StrEnum
import logging

logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)

"""
A Signal represents a trading signal generated by a strategy or indicator.

Attributes:
    side (Literal["buy", "sell"]): The direction of the signal, must be either "buy" or "sell"
    timestamp (DateTime): When the signal was generated, defaults to current time
    asset_id (str): Identifier for the asset/security this signal is for
    source (str): Name of strategy/indicator that generated this signal
    confidence (float): Confidence level between 0 and 1 indicating signal strength

Raises:
    ValueError: If confidence is not between 0 and 1
    TypeError: If side is not "buy" or "sell"

AUTHOR: Jack Regan
"""
class ValidSide(StrEnum):
    BUY = "buy"
    SELL = "sell"

def validate_side(side_str: str) -> ValidSide:
    try:
        return ValidSide(side_str)
    except ValueError:
        logging.error(f"Invalid side: {side_str}. Must be 'buy' or 'sell'.")
        raise ValueError(f"Invalid side: {side_str}. Must be 'buy' or 'sell'.")

def validate_confidence(value: float) -> float:
    if not 0 <= value <= 1:
        logging.error(f"Confidence must be between 0 and 1. Given confidence was {str(value)}")
        raise ValueError()
    return value

@dataclass(frozen=True)
class Signal:
    side: str = field(metadata={"validator": validate_side})
    asset_id: str
    source: str
    confidence: float = field(metadata={"validator": validate_confidence})
    timestamp: DateTime = field(default_factory=DateTime)
    
    def __post_init__(self):
        validate_confidence(self.confidence)
        validate_side(self.side)
        logging.info(f"The following Signal was created: {self.side} {self.asset_id} with confidence {self.confidence} for {self.source} at {self.timestamp}")
